#include "defines.h"
#include "stack.h"
//#include "a_star_algorithm.h"
#include "explorer.h"
#include "map_drawing.h"


// +++ TASK FLAGS ++
bool EXPLORE = true;

// +++ METHODS ++
// +++ Initialization +++

/* 
 *  Initializes MOVE_SPACE (MAP_DIM_X x MAP_DIM_Y) with FREE ('F')
 */
void init_MoveSpace() {
    for (int x = 0; x < MAP_DIM_X; x++) {
        for (int y = 0; y < MAP_DIM_Y; y++) {
            MOVE_SPACE[x][y] = FREE;
        }
    }
}

bool is_MoveSpace_explored()
{
	bool is_explored = true;
    for (int x = 0; x < MAP_DIM_X && is_explored; x++) {
        for (int y = 0; y < MAP_DIM_Y && is_explored; y++) {
            if (MOVE_SPACE[x][y] == FREE)
				is_explored = false;
        }
    }
	
	return is_explored;
}

/*
 *  Initializes current_state to given x, y and direction.
 *  If the given values are not valid, defaults are used.
 */
void init_current_state(char x, char y, char direction) {
    current_state.pos_x = (x < MAP_DIM_X) ? x : 0;
    current_state.pos_y = (y < MAP_DIM_Y) ? y : 0;
    current_state.direction = (direction >= NORTH && direction <= WEST) ? direction : NORTH;

	stack_init();
	
	// Add start position to stack
	Position tmp;
	tmp.x = current_state.pos_x;
	tmp.y = current_state.pos_y;
	
	MOVE_SPACE[current_state.pos_x][current_state.pos_y] = EXPLORED;
		
	stack_push(tmp);
}

void init_ground_detectors() {
    SetSensorLight(GROUND_DETECTOR_R);
    SetSensorLight(GROUND_DETECTOR_L);
    
    NORMAL_GROUND_COLOR = (Sensor(GROUND_DETECTOR_R) + Sensor(GROUND_DETECTOR_L)) / 2;
}

// +++ Explorer logic +++

void doStuff() {
	if (stack_length() == 0 || is_MoveSpace_explored())
	{
		EXPLORE = false;
		return;
	}		

    if(can_move(current_state.direction))   //move in current direction
    {
        move();
    }
    else if(find_new_direction() != -1)     //reorient
    {
        reorient();
    }
    else                                    //go back
    {
		ClearScreen();
		TextOut(0, LCD_LINE1, "Vor Pop");
		Wait(2000);
	
		ClearScreen();
        //TMP TODO: no clean solution
        Position current = stack_pop();
		TextOut(0, LCD_LINE1, "Pop Ok:");
		
		
        Position target = get_top();
        TextOut(0, LCD_LINE2, "Get Last Element Ok");
		
        //move to target
        move_to_target(current, target);
		TextOut(0, LCD_LINE3, "After Move To");
		Wait(1000);
    }
}

//current and target a in neighborhood
/*
 * move robot to target. current and target should be
 * neighbours! updates current state
 */
void move_to_target(Position current, Position target)
{
	Wait(1000);
	ClearScreen();
	TextOut(0, LCD_LINE1, "Pos: ");
	
	Position p = get_top();
	
	NumOut(30, LCD_LINE1, p.x);
	NumOut(40, LCD_LINE1, p.y);
	
	
	char d = current_state.direction;
	
	switch (d)
	{
		case NORTH:
			TextOut(0, LCD_LINE2, "Norden");
			break;
		case EAST:
			TextOut(0, LCD_LINE2, "Osten");
			break;
		case SOUTH:
			TextOut(0, LCD_LINE2, "Sueden");
			break;
		case WEST:
			TextOut(0, LCD_LINE2, "Westen");
			break;
		default:
			TextOut(0, LCD_LINE2, "KP");
	}
	
    if(current.x > target.x)
    {
        turn_to_direction(current_state.direction, WEST);
		TextOut(0, LCD_LINE3, "Nach Westen");
    }
    else if (current.x < target.x)
    {
        turn_to_direction(current_state.direction, EAST);
		TextOut(0, LCD_LINE3, "Nach Osten");
    }
    else if (current.y > target.y)
    {
        turn_to_direction(current_state.direction, SOUTH);
		TextOut(0, LCD_LINE3, "Nach Sueden");
    }
    else if(current.y < target.y)
    {
        turn_to_direction(current_state.direction, NORTH);
		TextOut(0, LCD_LINE3, "Nach Norden");
    }
    else
    {
        //janz blÃ¶d throw Exception;
        //current and target are equal
        return;
    }

	Wait(2000);
	
    drive(TILE_SIZE, MOVE_FORWARD);
    current_state.pos_x = target.x;
    current_state.pos_y = target.y;

}

/*
 * turn to target direction. updated current_state
 */
void turn_to_direction(char current_direction, char target_direction)
{
    char offset = (target_direction - current_direction);
	
	// Gilt wenn offset == 3 und macht offset = -1 => wechselt die Drehrichtung (auch fuer -3 => 1)
	if (abs(offset) > 2)
		offset = -(offset % 2);

    if(offset < 0)
    {
        for(char i = 0; i < abs(offset); ++i)
        {
            turnLeft();
        }
    }
    else if (offset > 0)
    {
        for(char i = 0; i < abs(offset); ++i)
        {
            turnRight();
        } 
    }
    
    current_state.direction = target_direction;
}

// /*
//  * Looks from current Position in current Direction and returns 
//  * true if move is possible.
//  */
// bool see()
// {
//     // look at my stuff, my stuff is amazing

//     bool is_move_with_current_state_possible = false;
//     if (can_move(current_state.direction)) {
//         is_move_with_current_state_possible = true;
//     }
//     return is_move_with_current_state_possible;
// }

/*
 *  Updates the current Position (int current_state) 
 *  with the given direction.
 */
void update_current_position(char direction) {
    switch (direction) {
        case NORTH: current_state.pos_y += 1;
                    break;
        case EAST:  current_state.pos_x += 1;
                    break;
        case SOUTH: current_state.pos_y += -1;
                    break;
        case WEST:  current_state.pos_x += -1;
                    break;
        default: ;
    }
}

/*
 *  Searches for new possible directions. If no new way is possible
 *  nothing happens! Otherwise direction of current_state is updated and
 *  the robot will rotate.
 *
 *  TODO: find clean solution if there is no new direction
 */
void reorient() {
    char new_direction = find_new_direction(); //-1 is possible

	if (new_direction >= 0)
		turn_to_direction(current_state.direction, new_direction);
}

/*
 *  Returns the value of the field next to the current
 *  position into the given direction.
 */
char get_field_in_direction(char direction) {
    char pos_area_x = current_state.pos_x;
    char pos_area_y = current_state.pos_y;
    switch (direction) {
        case NORTH: pos_area_y += 1;
                    break;
        case EAST:  pos_area_x += 1;
                    break;
        case SOUTH: pos_area_y += -1;
                    break;
        case WEST:  pos_area_x += -1;
                    break;
        default: ;
    }

    char field_value;

    if (
                (pos_area_x > MAP_DIM_X - 1) ||
                (pos_area_x < 0) ||
                (pos_area_y > MAP_DIM_Y - 1) ||
                (pos_area_y <0)
            ) {
        field_value = BORDER;
    } else {
        field_value = MOVE_SPACE[pos_area_x][pos_area_y];
    }

    return field_value;
}

/*
 *  Checks wether the current position + 
 *  one step to the given direction would result in a 
 *  valid position (FREE, TARGET, EXPLORED) (true is returned), or a 
 *  blocked position (OCCUPIED, BORDER) (false is returned).
 */
bool can_move(short direction) {
    short pos_new_x = current_state.pos_x;
    short pos_new_y = current_state.pos_y;

    switch (direction) {
        case NORTH: pos_new_y += 1;
                    break;
        case EAST:  pos_new_x += 1;
                    break;
        case SOUTH: pos_new_y += -1;
                    break;
        case WEST:  pos_new_x += -1;
                    break;
        default: ;
    }

    bool result = true;

    if (
            (pos_new_x > MAP_DIM_X - 1) ||
            (pos_new_x < 0) ||
            (pos_new_y > MAP_DIM_Y - 1) ||
            (pos_new_y < 0)
        ) {
        result = false;
    } else {
        if (MOVE_SPACE[pos_new_x][pos_new_y] == OCCUPIED || MOVE_SPACE[pos_new_x][pos_new_y] == EXPLORED) {
            result = false;
        }
    }

    return result;
}

/*
 *  Explorer-Robot moves in current direction.
 *  If the field is OCCUPIED, it will be marked (as OCCUPIED) in the MOVE_SPACE 
 *  and the the robot will go back. Reoriantation follows.
 *  If the field is FREE, the field will marked (as EXPLORED) in the MOVE_SPACE
 *  and the robot will go to this position.
 */
void move() {
    drive(TILE_SIZE, MOVE_FORWARD);
    if (is_occupied()) {
        update_current_position(current_state.direction);
        MOVE_SPACE[current_state.pos_x][current_state.pos_y] = OCCUPIED;
        drive(TILE_SIZE, MOVE_BACKWARD);
        update_current_position((current_state.direction + 2) % 4);
    } else {
		update_current_position(current_state.direction);
		MOVE_SPACE[current_state.pos_x][current_state.pos_y] = EXPLORED;
		
		Position tmp;
		tmp.x = current_state.pos_x;
		tmp.y = current_state.pos_y;
		
		stack_push(tmp);
	}
}

/*
 *  Looks at each direction (turning right from the current direction).
 *  If a FREE field is found this direction is returned.

 *  TODO: - If no FREE field is found we are running into an error! (-1 will be returned!)
 *        - A*-Algorithm?!  
*/
char find_new_direction() {
    char newDirection = current_state.direction;
    bool found = false;
    char counter = 0;
    while (!found) {
        newDirection = (newDirection + 1) % 4;
        if (get_field_in_direction(newDirection) == FREE) {
            found = true;
        }
        // All directions checked + nothing FREE
        if(counter == 4) {
            //return Error value
            newDirection = -1;
            found = true;
        }
        ++counter;
    }
    return newDirection; 
}

/*
 *  Checks if the Ground is occupied.
 */
bool is_occupied() {
    return check_ground();
}

/*
 *  Checks if the current ground color differs from the init value.
 */
bool check_ground() {
    SetSensorLight(GROUND_DETECTOR_R);
    SetSensorLight(GROUND_DETECTOR_L);

    return !((abs(NORMAL_GROUND_COLOR - Sensor(GROUND_DETECTOR_R)) < LIGHT_THRESHOLD) 
            && (abs(NORMAL_GROUND_COLOR - Sensor(GROUND_DETECTOR_L)) < LIGHT_THRESHOLD));
}

/*
 *  Rotates the robot on his position.
 *  direction = 1: right
 *  direction = -1: left
 */
void rotateOnSpot(char direction, float wheelDistance, float wheelRadius, int angle)
{
    int wheelRotationAngle = angle * ((wheelDistance / 2) / wheelRadius);

    RotateMotorEx(BOTH_DRIVE, SPEED, wheelRotationAngle, (-direction) * 100, true, true);
}


void moveForward(char speed) {
//void RotateMotorEx(byte outputs,char pwr, long angle, char turnpct, bool sync, bool stop)   
    RotateMotorEx(BOTH_DRIVE, speed, 360, 100, true, true);
    //OnFwd(BOTH_DRIVE, speed);
}

void moveBackward(char speed) {
    moveForward(-1 * speed);
}

void backOff() {
    moveBackward(SPEED);
}

void stopMove() {
    OnFwd(BOTH_DRIVE, 0);
}

void rotate90(char direction)
{   
    rotateOnSpot(direction, WHEEL_DISTANCE, WHEEL_RADIUS, 90);
    // RotateMotorEx(BOTH_DRIVE, SPEED, 225, -direction * 100, true, true);
}

void turnRight() {
    rotateOnSpot(DIRECTION_RIGHT, WHEEL_DISTANCE, WHEEL_RADIUS, 90);
}

void turnLeft() {
    rotateOnSpot(DIRECTION_LEFT, WHEEL_DISTANCE, WHEEL_RADIUS, 90);
}

void turnAround() {
    turnRight();
    turnRight();
}

void drive(int distance, int direction)
{
    int wheelRotationAngle = 2 * PI * WHEEL_RADIUS * distance * direction;

    RotateMotorEx(BOTH_DRIVE, SPEED, wheelRotationAngle, 0, true, true);
}


// +++ TASKS +++

task main() {
    init_ground_detectors();
}

task explore() {
    Follows (main);
    //init movespace and position and direction of explorer-robot
    init_MoveSpace();
    init_current_state(0, 0, NORTH);
	
    while(EXPLORE) {
        ClearScreen();
		NumOut(50, LCD_LINE1, stack.last_element);
		Wait(500);
		
		doStuff();
		
		
    }
	
	ClearScreen();
	TextOut(0, LCD_LINE1, "Fertig");
	Wait(2000);

    //try to draw Map on Screen
    Map map;
    map.x_dim = MAP_DIM_X;
    map.y_dim = MAP_DIM_Y;
    map.data = MOVE_SPACE;
    drawMapMoveSpace(map);

	// Senden
	
	StopAllTasks();
}
